{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SQLModel-translation","text":"<p>SQLModel-Translation is a Python library for adding translation support to SQLModel and FastAPI applications. This library was heavily inspired by django-modeltranslation</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Apply translations without modifying existing SQLModel classes.</li> <li>Write SQLModel queries without having to worry about the language.</li> <li>Automatically translate requests based on <code>Accept-Language</code> HTTP header.</li> <li>Fully compatible with Pydantic validation.</li> </ul> <p>See quickstart, reference and concepts for more details.</p>"},{"location":"concepts/","title":"Concepts","text":"<p>This section will explain several concepts in closer detail for when the reference might not be sufficient.</p>"},{"location":"concepts/#registering-models","title":"Registering models","text":"<p>SQLModel-translation can translate fields of SQLModel classes without modifying the original class.</p> <p>Consider the following example which translates <code>Book</code> into english and polish.</p> <p><pre><code>from modeltranslation import Translator, TranslationOptions\nfrom sqlmodel import SQLModel\n\n\nclass Book(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    title: str\n\ntranslator = Translator(\n    default_language=\"en\",\n    languages=(\"en\", \"pl\"),\n)\n\n@translator.register(Book)\nclass BookTranslationOptions(TranslationOptions):\n    fields = (\"title\",)\n    required_languages = (\"en\",)\n</code></pre> In practice <code>Book</code> now looks like this.</p> <p><pre><code>class Book(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    title: str | None\n    title_pl: str | None\n    title_en: str\n</code></pre> The pydantic model stays correct and as strict as possible.</p> <p>Let's see a more complicated example and explain it step by step.</p> <pre><code>from modeltranslation import Translator, TranslationOptions\nfrom sqlmodel import SQLModel\n\nclass Book(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    title: str\n    author: str\n\ntranslator = Translator(\n    default_language=\"en\",\n    languages=(\"en\", \"pl\", \"fr\", \"es\"),\n    fallback_languages={\"fr\": (\"pl\", \"en\"), \"default\": (\"fr\",)},\n)\n\n@translator.register(Book)\nclass BookTranslationOptions(TranslationOptions):\n    fields = (\"title\",)\n    required_languages = {\"fr\": (\"title\", \"author\"), \"default\": (\"title\",)}\n    fallback_values = {\"title\": (\"Title\"), \"author\": (\"No translation provided\")}\n</code></pre> <ol> <li> <p><code>fallback_languages={\"fr\": (\"es\", \"pl\"), \"default\": (\"en\",)}</code>     This means that when there is no value for french, spanish and polish will be tried next.     For other languages <code>en</code> will be used as the first fallback.</p> </li> <li> <p><code>required_languages = {\"fr\": (\"title\", \"author\"), \"default\": (\"title\",)}</code> Title is required in all languages. Additionally the author is required to be translated in french.</p> </li> <li> <p><code>fallback_values = {\"title\": (\"Title\"), \"author\": (\"No translation provided\")</code> When language fallbacks fail then fallback values will be used instead.</p> </li> </ol>"},{"location":"concepts/#exceptions","title":"Exceptions","text":"<p>Sometimes the translation configuration can be inconsistent. For example:</p> <p><pre><code>from modeltranslation import Translator, TranslationOptions\n\ntranslator = Translator(\n    default_language=\"en\",\n    languages=(\"en\", \"pl\"),\n)\n\nclass BookTranslationOptions(TranslationOptions):\n    fields = (\"title\",)\n    required_languages = (\"fr\")\n</code></pre> This is impossible, because <code>fr</code> is not declared in the translator. ImproperlyConfiguredError will be thrown whenever inconsistencies like this are detected.</p> <p>For more details about possible configuraion options see <code>Translator</code> and <code>TranslationOptions</code>. If this is not sufficient, try looking up the tests. Each test for a configuration option is an example exactly like this and is fairly readable to new users.</p>"},{"location":"concepts/#accessing-translated-fields","title":"Accessing translated fields","text":"<p>Rule 1 -     Reading the value from the original field returns the value translated to the current language.</p> <p>Rule 2 -     Assigning a value to the original field updates the value in the associated current language translation field.</p> <p>Rule 3 -     If both fields - the original and the current language translation field - are updated at the same time, the current language translation field wins.</p> <p>The original field is inaccessible and should be considered invalid.</p>"},{"location":"concepts/#using-sqlmodel-queries","title":"Using SQLModel queries","text":"<p>Registering translations makes all SQLModel queries work with the new translation fields.</p> <p>For example: <pre><code>update(Book).where(Book.author == \"J.R.R. Tolkien\").values(title=\"translation\")\nselect(Book).where(Book.title_en == \"english_title\")\n</code></pre></p> <p>There is one exception which might feel unnatural.</p> <pre><code>select(Book.title)\nselect(Book.title_en)\n</code></pre> <p>Selecting columns only reroutes to the correct column based on the active langugage. This means that any fallback languages or values configured both in <code>Translator</code>, <code>TranslationOptions</code> and will not apply here.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>To demonstrate how to use this library we will write a simple FastAPI application. The full example is available at <code>examples/quickstart.py</code>.</p> <p>First we will create a sqlite database.</p> <pre><code>from sqlmodel import Field, Session, SQLModel, StaticPool, create_engine\n\nengine = create_engine(\n    \"sqlite://\",\n    echo=True,\n    connect_args={\"check_same_thread\": False},\n    poolclass=StaticPool,\n)\n\ndef create_db_and_tables():\n    SQLModel.metadata.create_all(engine)\n</code></pre> <p>To begin create a <code>Book</code> class. <pre><code>class Book(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    title: str\n    author: str\n</code></pre></p> <p>To make <code>Book</code> translatable you need to create a <code>Translator</code>, <code>TranslationOptions</code> and register the <code>TranslationOptions</code> for your class.</p> <pre><code>from modeltranslation import TranslationOptions, Translator\n\ntranslator = Translator(\n    default_language='en',\n    languages=('en', 'pl'),\n)\n\n@translator.register(Book)\nclass BookTranslationOptions(TranslationOptions):\n    fields = (\"title\",)\n</code></pre> <p>As a result <code>Book</code> gained 2 new fields - <code>Book.title_en</code>, <code>Book.title_pl</code>. We can now do:</p> <p><pre><code>book = Book(title = '1984', author='George Orwell')\nassert book.title == '1984'\nassert book.title_en == '1984'\nassert book.title_pl is None\n</code></pre> Notice how <code>book.title == book.title_en</code>.</p> <p>The translated <code>title</code> is redirected to the field for the current active language which is english. That's because we created the translator with <code>default_language='en'</code>.</p> <p>The new fields also work in all SQLModel queries and get transformed based on the active language. <pre><code>from sqlmodel import select\n\n# These are equivalent\nselect(Book).where(Book.title == \"english translation\")\nselect(Book).where(Book.title_en == \"english translation\")\n</code></pre></p> <p>Before moving on we will add more books to the database. <pre><code>create_db_and_tables()\n\nbooks = [\n    Book(title_en=\"english_title_1\", title_pl=\"polish_title_1\", author=\"J.R.R. Tolkien\"),\n    Book(title_en=\"english_title_2\", title_pl=\"polish_title_2\", author=\"Harper Lee\"),\n]\nwith Session(engine) as session:\n    session.add_all(books)\n    session.commit()\n</code></pre></p> <p>To integrate the project with FastAPI we use the <code>apply_translation</code>. This makes FastAPI set the active language for each request based on the <code>Accept-Language</code> HTTP header.</p> <p><pre><code>from modeltranslation import apply_translation\nfrom fastapi import FastAPI\n\n\napp = FastAPI()\n\napply_translation(app, translator)\n\n\n@app.get(\"/all\")\ndef get_books() -&gt; list[Book]:\n    with Session(engine) as session:\n        return session.exec(select(Book)).all()\n\n\n@app.get(\"/titles\")\ndef get_titles() -&gt; list[Book]:\n    with Session(engine) as session:\n        return session.exec(select(Book.title)).all()\n\n\n@app.post(\"/create\")\ndef create_book(book: Book) -&gt; Book:\n    with Session(engine) as session:\n        session.add(book)\n        session.commit()\n        session.refresh(book)\n        return book\n</code></pre> We can now run the server with <code>fastapi dev quickstart.py</code>. The server by default runs on <code>http://127.0.0.1:8000</code>, with docs at <code>http://127.0.0.1:8000/docs</code>.</p> <p>Now we will look at how translations are handled in endpoints.</p> <p><code>/all</code> returns a list of books with translated titles.</p> <pre><code>[\n  {\n    \"author\": \"J.R.R. Tolkien\",\n    \"title\": \"english_title_1\",\n    \"id\": 1\n  },\n  {\n    \"author\": \"Harper Lee\",\n    \"title\": \"english_title_2\",\n    \"id\": 2\n  }\n]\n</code></pre> <p><code>/titles</code> returns translated titles.</p> <pre><code>[\n  \"english_title_1\",\n  \"english_title_2\"\n]\n</code></pre> <p>We can also take a look at the schema for <code>/create</code> using the FastAPI docs.</p> <pre><code>{\n  \"id\": 0,\n  \"title\": \"string\",\n  \"author\": \"string\",\n  \"title_en\": \"string\",\n  \"title_pl\": \"string\"\n}\n</code></pre> <p>When creating a <code>Book</code> you we can specify all translation fields manually, or use the <code>title</code> field and let it redirect based on the active language.</p> <p><code>Translator</code>, and <code>TranslationOptions</code> support other configuration options regarding required languages, and fallback behaviour.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#modeltranslation.Translator","title":"Translator","text":"<pre><code>Translator(\n    default_language: str,\n    languages: tuple[str, ...],\n    fallback_languages: dict[str, tuple[str, ...]] | None = None,\n)\n</code></pre> <p>A translator object that manages translations for registered SQLModel classes.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ImproperlyConfiguredError</code>             \u2013            <p>If the configuration is internally inconsistent.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>register</code>             \u2013              <p>Register a SQLModel class for translations.</p> </li> </ul> Source code in <code>src/modeltranslation/translator.py</code> <pre><code>def __init__(\n    self,\n    default_language: str,\n    languages: tuple[str, ...],\n    fallback_languages: dict[str, tuple[str, ...]] | None = None,\n) -&gt; None:\n    \"\"\"Construct a translator object.\n\n    Args:\n        default_language (str): The language to use if no language was set externally.\n\n        languages (tuple[str, ...]): All supported languages i.e the translations you want to store.\n\n        fallback_languages (dict[str, tuple[str, ...]] | None): Fallbacks for each language\n            used when the active language is not in `languages`. An example:\n            `{\n              'default': ('en', 'pl', 'de'),\n              'fr': 'es'\n            }`.\n            The default key is required.\n\n    Raises:\n        ImproperlyConfiguredError: If the configuration is internally inconsistent.\n\n    \"\"\"\n    self._active_language: ContextVar[str] = ContextVar(\"current_locale\", default=default_language)\n\n    self._default_language: str = default_language\n\n    self._languages: tuple[str, ...] = languages\n\n    # fallbacks for untranslated languages\n    self._fallback_languages: dict[str, tuple[str, ...]] = {\"default\": (self._default_language,)}\n    if fallback_languages:\n        self._fallback_languages = fallback_languages\n\n    self._validate_translator_object()\n</code></pre>"},{"location":"reference/#modeltranslation.Translator(default_language)","title":"<code>default_language</code>","text":"(<code>str</code>)           \u2013            <p>The language to use if no language was set externally.</p>"},{"location":"reference/#modeltranslation.Translator(languages)","title":"<code>languages</code>","text":"(<code>tuple[str, ...]</code>)           \u2013            <p>All supported languages i.e the translations you want to store.</p>"},{"location":"reference/#modeltranslation.Translator(fallback_languages)","title":"<code>fallback_languages</code>","text":"(<code>dict[str, tuple[str, ...]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Fallbacks for each language used when the active language is not in <code>languages</code>. An example: <code>{   'default': ('en', 'pl', 'de'),   'fr': 'es' }</code>. The default key is required.</p>"},{"location":"reference/#modeltranslation.Translator.register","title":"register","text":"<pre><code>register(model: type[SQLModel]) -&gt; Callable\n</code></pre> <p>Register a SQLModel class for translations.</p> <p>This function returns a decorator that applies <code>TranslationOptions</code> to the given SQLModel class. After applying, the model will have translation accessors and metadata set up automatically.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ImproperlyConfiguredError</code>             \u2013            <p>If the translation options are inconsistent with the Translator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from sqlmodel import SQLModel\n&gt;&gt;&gt; from modeltranslation import Translator\n...\n&gt;&gt;&gt; class Book(SQLModel, table=True):\n...     title: str\n...\n&gt;&gt;&gt; translator = Translator(\n...     default_language=\"en\",\n...     languages=(\"en\", \"pl\"))\n...\n&gt;&gt;&gt; @translator.register(Book)\n... class BookTranslationOptions(TranslationOptions):\n...     fields=('title',)\n</code></pre> Source code in <code>src/modeltranslation/translator.py</code> <pre><code>def register(self, model: type[SQLModel]) -&gt; Callable:\n    \"\"\"Register a SQLModel class for translations.\n\n    This function returns a decorator that applies `TranslationOptions`\n    to the given SQLModel class. After applying, the model\n    will have translation accessors and metadata set up automatically.\n\n    Args:\n        model (SQLModel): the class to apply translations on.\n\n    Raises:\n        ImproperlyConfiguredError: If the translation options are inconsistent with the Translator.\n\n    Examples:\n        &gt;&gt;&gt; from sqlmodel import SQLModel\n        &gt;&gt;&gt; from modeltranslation import Translator\n        ...\n        &gt;&gt;&gt; class Book(SQLModel, table=True):\n        ...     title: str\n        ...\n        &gt;&gt;&gt; translator = Translator(\n        ...     default_language=\"en\",\n        ...     languages=(\"en\", \"pl\"))\n        ...\n        &gt;&gt;&gt; @translator.register(Book)\n        ... class BookTranslationOptions(TranslationOptions):\n        ...     fields=('title',)\n\n    \"\"\"\n\n    def decorator(options: TranslationOptions) -&gt; None:\n        self._replace_accessors(model, options)\n        self._rebuild_model(model, options)\n\n    return decorator\n</code></pre>"},{"location":"reference/#modeltranslation.Translator.register(model)","title":"<code>model</code>","text":"(<code>SQLModel</code>)           \u2013            <p>the class to apply translations on.</p>"},{"location":"reference/#modeltranslation.TranslationOptions","title":"TranslationOptions","text":"<p>Base class for configuring the translation of SQLModel classes.</p> <p>This class defines which fields are translated, which translations are required and how to handle missing values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from modeltranslation import TranslationOptions\n&gt;&gt;&gt; class BookTranslationOptions(TranslationOptions):\n...     fields = (\"title\",)\n...     required_languages = (\"en\",)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>fallback_languages</code>               (<code>dict[str, tuple[str, ...]] | None</code>)           \u2013            <p>Languages to use when the current language is missing.</p> </li> <li> <code>fallback_values</code>               (<code>dict[str, Any] | Any</code>)           \u2013            <p>The values to use if all fallback languages yielded no value.</p> </li> <li> <code>fields</code>               (<code>tuple[str, ...]</code>)           \u2013            <p>Names of fields to translate.</p> </li> <li> <code>required_languages</code>               (<code>dict[str, tuple[str, ...]] | tuple[str, ...] | None</code>)           \u2013            <p>The required translations for this class.</p> </li> </ul>"},{"location":"reference/#modeltranslation.TranslationOptions.fallback_languages","title":"fallback_languages  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fallback_languages: dict[str, tuple[str, ...]] | None = None\n</code></pre> <p>Languages to use when the current language is missing.</p> Example <p><code>('en', 'pl', 'de')</code></p> <p>The fallbacks can be also specified with a dictionary. The default key is required.</p> Example <pre><code>{\n  'default': ('en', 'pl', 'de'),\n  'fr': 'es'\n}\n</code></pre>"},{"location":"reference/#modeltranslation.TranslationOptions.fallback_values","title":"fallback_values  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fallback_values: dict[str, Any] | Any = None\n</code></pre> <p>The values to use if all fallback languages yielded no value.</p> Example <p><code>('No translation provided')</code></p> <p>It's also possible to specify a fallback value for each field.</p> Example <pre><code>{\n  'title': ('No translation'),\n  'author': ('No translation provided')\n}\n</code></pre>"},{"location":"reference/#modeltranslation.TranslationOptions.fields","title":"fields  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fields: tuple[str, ...] = ()\n</code></pre> <p>Names of fields to translate.</p> Example <p><code>(</code>title<code>,</code>description<code>)</code></p>"},{"location":"reference/#modeltranslation.TranslationOptions.required_languages","title":"required_languages  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required_languages: dict[str, tuple[str, ...]] | tuple[str, ...] | None = None\n</code></pre> <p>The required translations for this class.</p> <p>This also affects the pydantic model and typehints.</p> Example <p><code>('en',)</code></p> <p>The fallbacks can be also specified with a dictionary. This makes it possible to set the requirements per field.</p> Example <pre><code>{\n  'en': ('title', 'author'),\n  'default': ('title',)\n}\n</code></pre> <p>The <code>default</code> key is required. For english, title and author are required. For all other languages only title is required.</p>"},{"location":"reference/#modeltranslation.apply_translation","title":"apply_translation","text":"<pre><code>apply_translation(app: FastAPI, translator: Translator) -&gt; None\n</code></pre> <p>Configure the app set the current language as a context variable.</p> <p>Applies middleware to FastAPI app which sets language based on the accept-language HTTP header. The resolved language is stored in the translator per execution context.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastapi import FastAPI\n&gt;&gt;&gt; from modeltranslation import Translator, apply_translation\n...\n&gt;&gt;&gt; translator = Translator(\n...     default_language=\"en\",\n...     languages=(\"en\", \"pl\"),\n... )\n&gt;&gt;&gt; app = FastAPI()\n&gt;&gt;&gt; apply_translation(app, translator)\n</code></pre> Note <p>In a typical use case, you would register translations with the translator before calling this function.</p> Source code in <code>src/modeltranslation/fastapi_middleware.py</code> <pre><code>def apply_translation(app: FastAPI, translator: Translator) -&gt; None:\n    \"\"\"Configure the app set the current language as a context variable.\n\n    Applies middleware to FastAPI app which sets language based on the accept-language HTTP header.\n    The resolved language is stored in the translator per execution context.\n\n    Args:\n        app (FastAPI): FastAPI application.\n        translator (Translator): The translator used to register translations in this app.\n\n    Examples:\n        &gt;&gt;&gt; from fastapi import FastAPI\n        &gt;&gt;&gt; from modeltranslation import Translator, apply_translation\n        ...\n        &gt;&gt;&gt; translator = Translator(\n        ...     default_language=\"en\",\n        ...     languages=(\"en\", \"pl\"),\n        ... )\n        &gt;&gt;&gt; app = FastAPI()\n        &gt;&gt;&gt; apply_translation(app, translator)\n\n    Note:\n        In a typical use case, you would register translations with\n        the translator before calling this function.\n\n    \"\"\"\n\n    @app.middleware(\"http\")\n    async def set_locale_context(request: Request, call_next):\n        header = request.headers.get(\"accept-language\")\n        locale = header.split(\",\") if header else None\n        if locale:\n            for entry in locale:\n                lang = entry.split(\";\")\n                if lang[0] in translator.get_languages():\n                    translator.set_active_language(str(lang[0]))\n                    break\n        return await call_next(request)\n</code></pre>"},{"location":"reference/#modeltranslation.apply_translation(app)","title":"<code>app</code>","text":"(<code>FastAPI</code>)           \u2013            <p>FastAPI application.</p>"},{"location":"reference/#modeltranslation.apply_translation(translator)","title":"<code>translator</code>","text":"(<code>Translator</code>)           \u2013            <p>The translator used to register translations in this app.</p>"},{"location":"reference/#modeltranslation.ImproperlyConfiguredError","title":"ImproperlyConfiguredError","text":"<pre><code>ImproperlyConfiguredError(message: str)\n</code></pre> <p>Raised when the configuration is internally inconsistent.</p> Source code in <code>src/modeltranslation/exceptions.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message)\n</code></pre>"}]}